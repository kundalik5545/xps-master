# Cursor Rules for xps-master-by-jk

Project context

- Framework: Next.js (App Router), React 19
- Styling: Tailwind CSS v4, Radix UI primitives, custom components in `components/ui` and `components/myUi`
- Forms/validation: `react-hook-form` + `zod`
- Data: Prisma ORM (SQLite by default), client exported from `db/db.config.js`
- Aliases: `@/*` maps to the repository root (see `jsconfig.json`)

General guidelines

- Prefer clear, readable, and maintainable code over clever one-liners.
- Use early returns instead of deep nesting; avoid unnecessary try/catch.
- Follow existing export patterns:
  - Named exports for utilities (for example, `lib/ApiResponse.js`, `lib/Log.js`).
  - Default export for shared singletons (for example, Prisma in `db/db.config.js`).
- Preserve existing indentation and formatting; do not reformat unrelated code.
- Keep comments minimal; only add when they capture non-obvious rationale or caveats.

UI conventions

- Use `components/ui/*` and `components/myUi/*` before adding new UI primitives.
- Compose classNames with `cn` from `lib/utils.js`.
- Prefer Radix UI components where appropriate and Tailwind utility classes for layout.

Server and data access

- Use Prisma via `import prisma from "@/db/db.config"` for database access.
- Return API/action results using `ApiRes(success, statusCode, message, data)` from `lib/ApiResponse.js`.
- Use `log`/`logger` from `lib/Log.js` for structured logging.
- Place server actions and data-access helpers under `actions/**` mirroring feature areas.

Validation and schemas

- Define form/data schemas with `zod` under `lib/Schema/*`.
- Validate input at the boundary (server actions / API routes) before DB calls.

Routing and files

- App Router lives under `app/**`. Prefer colocating components inside feature folders.
- Shared components belong in `components/**`.
- Keep environment-specific values in `.env` (for example, `DATABASE_URL`).

Prisma/DB

- Schema is in `prisma/schema.prisma`; default datasource is SQLite with `prisma/dev.db`.
- When changing the schema:
  1. `npx prisma migrate dev --name <change>`
  2. `npx prisma generate`
- Generated client outputs to `generated/prisma` (already committed for convenience).

Imports

- Use the `@/` alias for root imports. Examples:
  - `@/db/db.config`
  - `@/lib/ApiResponse`
  - `@/components/ui/button`

Testing and linting

- Run `npm run lint` locally and fix issues before committing.
- Prefer small, focused edits. If a change spans many files, split into logical commits.

Performance

- Avoid unnecessary re-renders; memoize heavy components and values.
- Defer non-critical work; prefer lazy import for rarely used components.

Security

- Never commit secrets. Keep credentials in `.env` and access via `process.env`.
- Validate and sanitize all external inputs using `zod` schemas.

Pull requests and commit style

- Use descriptive commit messages in imperative mood (for example, "Add portals form validation").
- Summarize user impact and any breaking changes in the PR description.

When adding new code

- Reuse existing helpers: `ApiRes`, `log`/`logger`, `cn`, and `PortalFormSchema` patterns.
- Keep feature-specific actions/components close to their pages in `app/(main)/**` or `actions/**`.

Cursor-specific behaviors

- Prefer minimal diffs; avoid reformatting unrelated files.
- Reference existing code in answers using line-number code references when possible.
- For new code proposals in chat, use proper fenced code blocks with language tags.

Portals-style feature blueprint (replicate this pattern)

- Structure (example for portals)

  - `app/(main)/<area>/<feature>/page.jsx` (client component)
  - `app/(main)/<area>/<feature>/_components/`
    - `<Feature>Form.jsx`
    - `<Feature>Table.jsx`
    - `<Feature>Filter.jsx`
    - `<feature>Column.js`
  - `actions/<area>/<feature>.js` (server actions)

- Server actions file

  - Add `'use server'` pragma at top.
  - Import: `prisma` from `@/db/db.config`, `ApiRes` from `@/lib/ApiResponse`, `STATUS` from `@/lib/Statuses`.
  - Validation: use `ZodFormValidator({ payload, formSchema })` with a `zod` schema in `lib/Schema/*`.
  - Export the following named functions:
    - `getAll<Plural>()` → `ApiRes(true, STATUS.OK, msg, data)`
    - `addUpdate<Singular>({ payload, actions })` where `actions ∈ {"add","update"}`
      - For `add`, validate `payload` (or `payload.formData`) and `prisma.<model>.create({ data })`
      - For `update`, expect `{ id, formData }` inside `payload`, validate, and `prisma.<model>.update({ where: { id }, data })`
    - `delete<Singular>(id)` → `prisma.<model>.delete({ where: { id } })`
    - `multiDelete<Plural>(ids)` → `prisma.<model>.deleteMany({ where: { id: { in: ids } } })`
  - Model name must match Prisma client (lowercased plural, e.g., `portals`, `xpsMenus`).
  - Always return `ApiRes` with populated `data` field; consumers should read `res.data` (not custom keys).

- Page component (`page.jsx`)

  - Mark as client: `'use client'`.
  - Local state: `isDialogOpen`, `isEditing`, `<feature>Data` (array), `editingData` (nullable), `loading`.
  - `useEffect` fetch: call `getAll<Plural>()` on mount, set `<feature>Data` from `res.data`.
  - `handleSubmit(formData)`
    - Derive `actions` from `isEditing`.
    - Build `payload`: for update include `{ formData, id: editingData.id }`; for add use `formData`.
    - Call `addUpdate<Singular>({ payload, actions })`.
    - On success, optimistically update local array (map/replace on update, append on add), reset editing state, close modal, and toast via `sonner`.
  - Provide `onEdit(record)` to set `editingData` and open the modal; wire `onDelete`, `handleMultiDelete` to actions.
  - Render:
    - `PageHeader` with add button toggling modal state
    - `<Feature>Table` with `data`, `columns`, bulk delete handler, `loading`
    - `FormModal` wrapping `<Feature>Form` with `onFormSubmit` and `editingData`

- Table component (`<Feature>Table.jsx`)

  - Use `@tanstack/react-table` with state: `sorting`, `columnFilters`, `rowSelection`.
  - Expose `resetFilters()` clearing all three states.
  - `handleMultiDelete()` should collect selected row ids, call parent `onMultiRowDelete(ids)`, and reset selection after the promise resolves.
  - Use shared UI: `Table`, `TableHeading`, `TableNoResults`, `TableRowCellCheckBox`, `TableRowCellText`, `TablePagination` from `components/ui` and `components/myUi`.
  - For link-like cells (e.g., URLs), render a `Button variant="link"` opening `window.open(value, "_blank")`.

- Columns config (`<feature>Column.js`)

  - Default export a function `({ onEdit, onDelete }) => ColumnDef[]`.
  - Define column objects with `accessorKey`, `header`, and flags (`enableSorting`, `enableHiding`, `enableColumnFilter`).
  - Add an actions column with `id: 'actions'`, `header: () => <TableActionsHeader />`, and `cell: ({ row }) => <TableActions record={row.original} onEdit={onEdit} onDelete={onDelete} />`.

- Form component (`<Feature>Form.jsx`)

  - Client component using `react-hook-form` with `zodResolver(schema)`.
  - `defaultValues`: use `editingData` if present; otherwise provide empty defaults for controlled inputs.
  - Submit calls `onFormSubmit(values)`; include explicit Reset handling (`form.reset(); form.clearErrors();`).
  - Use shared `Form`, `FormField`, `FormItem`, `FormLabel`, `FormControl`, `FormMessage`, and inputs from `components/ui`.
  - Follow the portals example for optional password visibility toggling where relevant.

- Feedback and errors

  - Use `sonner` to toast success and failures at the page level.
  - Server actions must catch errors and return `ApiRes(false, STATUS.INTERNAL_SERVER_ERROR, message, null)`.

- Naming rules
  - Files: `page.jsx`, `<Feature>Form.jsx`, `<Feature>Table.jsx`, `<Feature>Filter.jsx`, `<feature>Column.js`.
  - Actions: `getAll<Plural>`, `addUpdate<Singular>`, `delete<Singular>`, `multiDelete<Plural>`.
  - Keep feature directories under `app/(main)/<area>/<feature>` and mirror in `actions/<area>/<feature>.js`.
